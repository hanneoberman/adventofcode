{
  "hash": "b4122bb6cfd04a3b76117391f499472f",
  "result": {
    "markdown": "---\ntitle: \"2023: Day 4\"\ndate: 2023-12-4\ncategories:\n  - R\ndraft: false\n---\n\n\n## Setup\n\n[The original challenge](https://adventofcode.com/2023/day/4)\n\n[My data](input){target=\"_blank\"}\n\n## Part 1\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(aochelpers)\n# other options: aoc_input_data_frame(), aoc_input_matrix()\ninput <- aoc_input_vector(4, 2023)\nhead(input)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Card   1: 10  5 11 65 27 43 44 29 24 69 | 65 66 18 14 17 97 95 34 38 23 10 25 22 15 87  9 28 43  4 71 89 20 72  5  6\"\n[2] \"Card   2: 25 43 15 31 45 19 36 73 34 85 | 92 11 85 68 74 20 19 71  1 36 43 32 77 33 14 31 73 15 45 83 34 25  6 88 57\"\n[3] \"Card   3:  4 46 42 23 18 98 59 75 19 57 | 22  3 75 80 42 23 59 39 98 38 18 21 67 57 20 25 71 26 64  4 83 79 91 65 90\"\n[4] \"Card   4: 92 13 56 27 19 44 70 93 32 66 | 38  4 19 75 87 93 32  1 23 14 51 22 42 44 33 63 13 56 70 66 18 92 47 53 27\"\n[5] \"Card   5: 25 18 30 45 23 80 91 13 47 61 | 62 45 71 30 39 19 61 68 23 80 91 96 25 58 13 88 67 29 60  2 74 55 12 83 46\"\n[6] \"Card   6: 20 36 26 18 61 35 94 58 79 19 | 85 68 56  7 53 58 19 20 79 59 26 61 18 15 94 33 29 71 35 89 17 36  3 67 72\"\n```\n:::\n:::\n\n\nConvert to dataframe then split into winning numbers and scratch numbers.\n\n::: {.cell}\n\n```{.r .cell-code}\ndat <- read.table(text = input)\ndat_win <- dat[, 3:12]\ndat_own <- dat[, 14:38]\n```\n:::\n\n\nCheck how many of the numbers in row 1 are wins.\n\n::: {.cell}\n\n```{.r .cell-code}\ndat_own[1, ] %in% dat_win[1, ] |> \n\tsum()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4\n```\n:::\n:::\n\n\nWith 4 winning numbers, row 1 yields 16 points.\n\n::: {.cell}\n\n```{.r .cell-code}\n2^4\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 16\n```\n:::\n:::\n\n\nThis can be converted to a function.\n\n::: {.cell}\n\n```{.r .cell-code}\nexponentiate <- \\(x) {2^(x) - 2^(x-1)}\n```\n:::\n\n\nTest the function.\n\n::: {.cell}\n\n```{.r .cell-code}\nexponentiate(4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 8\n```\n:::\n:::\n\n\nNow, apply this to all rows.\n\n::: {.cell}\n\n```{.r .cell-code}\nrow_sums <- purrr::map_dbl(1:nrow(dat), ~{\n\tdat_own[.x, ] %in% dat_win[.x, ] |> \n\t\tsum() |>\n\t\texponentiate()\n})\n```\n:::\n\n\nThen add the row values to obtain the total.\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(row_sums)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 21935.5\n```\n:::\n:::\n\n\nThis does not yield an integer, which is unexpected. The culpit is the value 0.\n\n::: {.cell}\n\n```{.r .cell-code}\nexponentiate(0)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.5\n```\n:::\n:::\n\n\nThe function should be adapted to allow for 0 wins.\n\n::: {.cell}\n\n```{.r .cell-code}\nexponentiate <- function(x) {\n\tif (x == 0) {return(x)}\n\tif (x > 0) {2^(x) - 2^(x - 1)}\n\t}\n```\n:::\n\n\nTest again.\n\n::: {.cell}\n\n```{.r .cell-code}\nexponentiate(0)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0\n```\n:::\n:::\n\n\nAnd compute the total.\n\n::: {.cell}\n\n```{.r .cell-code}\npurrr::map_dbl(1:nrow(dat), ~{\n\tdat_own[.x, ] %in% dat_win[.x, ] |> \n\t\tsum() |>\n\t\texponentiate()\n}) |> sum()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 21919\n```\n:::\n:::\n\n\n\n\n## Part 2\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}